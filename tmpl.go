package main

import (
	"errors"
	"html/template"
	"io"
	"regexp"
	"strings"

	"github.com/fatih/camelcase"
)

var headTmpl = template.Must(template.New("head").Parse(`
// Code generated by github.com/acomagu/optional. DO NOT EDIT.

package {{.PkgName}}
`))

type headTmplData struct {
	PkgName string
}

func writeHeadTmpl(w io.Writer, pkgName string) error {
	data := &headTmplData{
		PkgName: pkgName,
	}

	if err := headTmpl.Execute(w, data); err != nil {
		return err
	}

	return nil
}

var tmpl = template.Must(template.New("opt").Parse(`
// {{.Name}}
type Optional{{.Name}} struct {
	v   {{.Type}}
	has bool
}

{{if .ExportFactory -}}
func None{{.Name}}() Optional{{.Name}} {
{{else -}}
func none{{.Name}}() Optional{{.Name}} {
{{end -}}
	return Optional{{.Name}}{}
}

{{if .ExportFactory -}}
func Some{{.Name}}(v {{.Type}}) Optional{{.Name}} {
{{else -}}
func some{{.Name}}(v {{.Type}}) Optional{{.Name}} {
{{end -}}
	return Optional{{.Name}}{
		v:   v,
		has: true,
	}
}

{{if .ExportGet -}}
func (o Optional{{.Name}}) Get() ({{.Type}}, bool) {
{{else -}}
func (o Optional{{.Name}}) get() ({{.Type}}, bool) {
{{end -}}
	return o.v, o.has
}
`))

type tmplData struct {
	Type          string
	Name          string
	LowerName     string
	ExportFactory bool
	ExportGet     bool
}

var typeNameRegexp = regexp.MustCompile(`^\*?\S+$`)
var optNameRegexp = regexp.MustCompile(`^[A-Z]\S*$`)

func newTmplData(typName, name string, exportFactory, exportGet bool) (*tmplData, error) {
	if !typeNameRegexp.MatchString(typName) {
		return nil, errors.New("invalid type name")
	}

	if !optNameRegexp.MatchString(name) {
		return nil, errors.New("invalid opt name")
	}

	lowerName := lowerCamelCase(name)

	return &tmplData{
		Type:          typName,
		Name:          name,
		LowerName:     lowerName,
		ExportFactory: exportFactory,
		ExportGet:     exportGet,
	}, nil
}

func lowerCamelCase(s string) string {
	es := camelcase.Split(s)
	es[0] = strings.ToLower(es[0])
	return strings.Join(es, "")
}

func writeTmpl(w io.Writer, typName, name string, exportFactory, exportGet bool) error {
	data, err := newTmplData(typName, name, exportFactory, exportGet)
	if err != nil {
		return err
	}

	return tmpl.Execute(w, data)
}
